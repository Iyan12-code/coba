{"version":3,"file":"carousel.min.js","sources":["../src/shared/constants.ts","../src/shared/injectSymbols.ts","../src/shared/slideRegistry.ts","../src/utils/createCloneSlides.ts","../src/utils/disableChildrenTabbing.ts","../src/utils/getNumberInRange.ts","../src/utils/getScaleMultipliers.ts","../src/utils/getSnapAlignOffset.ts","../src/utils/i18nFormatter.ts","../src/utils/mapNumberToRange.ts","../src/utils/throttle.ts","../src/utils/toCssValue.ts","../src/components/ARIA/ARIA.ts","../src/components/Carousel/carouselProps.ts","../src/components/Carousel/Carousel.ts","../src/utils/except.ts","../src/utils/calculateAverage.ts","../src/composables/useHover.ts","../src/composables/useDrag.ts","../src/utils/getDraggedSlidesCount.ts","../src/composables/useWheel.ts","../src/components/Icon/Icon.types.ts","../src/components/Icon/Icon.ts","../src/components/Navigation/Navigation.ts","../src/components/Pagination/Pagination.ts","../src/components/Slide/Slide.ts"],"sourcesContent":["import { CarouselConfig } from './types'\n\nexport const BREAKPOINT_MODE_OPTIONS = ['viewport', 'carousel'] as const\n\nexport const DIR_MAP = {\n  'bottom-to-top': 'btt',\n  'left-to-right': 'ltr',\n  'right-to-left': 'rtl',\n  'top-to-bottom': 'ttb',\n} as const\n\nexport const DIR_OPTIONS = [\n  'ltr',\n  'left-to-right',\n  'rtl',\n  'right-to-left',\n  'ttb',\n  'top-to-bottom',\n  'btt',\n  'bottom-to-top',\n] as const\n\nexport const I18N_DEFAULT_CONFIG = {\n  ariaGallery: 'Gallery',\n  ariaNavigateToPage: 'Navigate to page {slideNumber}',\n  ariaNavigateToSlide: 'Navigate to slide {slideNumber}',\n  ariaNextSlide: 'Navigate to next slide',\n  ariaPreviousSlide: 'Navigate to previous slide',\n  iconArrowDown: 'Arrow pointing downwards',\n  iconArrowLeft: 'Arrow pointing to the left',\n  iconArrowRight: 'Arrow pointing to the right',\n  iconArrowUp: 'Arrow pointing upwards',\n  itemXofY: 'Item {currentSlide} of {slidesCount}',\n} as const\n\nexport const NORMALIZED_DIR_OPTIONS = Object.values(DIR_MAP)\n\nexport const SLIDE_EFFECTS = ['slide', 'fade'] as const\n\nexport const SNAP_ALIGN_OPTIONS = [\n  'center',\n  'start',\n  'end',\n  'center-even',\n  'center-odd',\n] as const\n\nexport const DEFAULT_MOUSE_WHEEL_THRESHOLD = 10\nexport const DEFAULT_DRAG_THRESHOLD = 0.08\n\nexport const DEFAULT_CONFIG: CarouselConfig = {\n  autoplay: 0,\n  breakpointMode: BREAKPOINT_MODE_OPTIONS[0],\n  breakpoints: undefined,\n  dir: DIR_OPTIONS[0],\n  enabled: true,\n  gap: 0,\n  height: 'auto',\n  i18n: I18N_DEFAULT_CONFIG,\n  ignoreAnimations: false,\n  itemsToScroll: 1,\n  itemsToShow: 1,\n  modelValue: 0,\n  mouseDrag: true,\n  mouseWheel: false,\n  pauseAutoplayOnHover: false,\n  preventExcessiveDragging: false,\n  slideEffect: SLIDE_EFFECTS[0],\n  snapAlign: SNAP_ALIGN_OPTIONS[0],\n  touchDrag: true,\n  transition: 300,\n  transitionEasing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)', // ease-out-quad for smooth transitions\n  wrapAround: false,\n}\n","import { InjectionKey } from 'vue'\n\nimport { InjectedCarousel } from '@/components/Carousel'\n\n// Use a symbol for inject provide to avoid any kind of collision with another lib\n// https://vuejs.org/guide/components/provide-inject#working-with-symbol-keys\nexport const injectCarousel = Symbol('carousel') as InjectionKey<\n  InjectedCarousel | undefined\n>\n","import { ComponentInternalInstance, EmitFn, shallowReactive } from 'vue'\n\nconst createSlideRegistry = (emit: EmitFn) => {\n  const slides = shallowReactive<Array<ComponentInternalInstance>>([])\n\n  const updateSlideIndexes = (startIndex?: number) => {\n    if (startIndex !== undefined) {\n      slides.slice(startIndex).forEach((slide, offset) => {\n        slide.exposed?.setIndex(startIndex + offset)\n      })\n    } else {\n      slides.forEach((slide, index) => {\n        slide.exposed?.setIndex(index)\n      })\n    }\n  }\n\n  return {\n    cleanup: () => {\n      slides.splice(0, slides.length)\n    },\n\n    getSlides: () => slides,\n\n    registerSlide: (slide: ComponentInternalInstance, index?: number) => {\n      if (!slide) return\n\n      if (slide.props.isClone) {\n        return\n      }\n\n      const slideIndex = index ?? slides.length\n      slides.splice(slideIndex, 0, slide)\n      updateSlideIndexes(slideIndex)\n      emit('slide-registered', { slide, index: slideIndex })\n    },\n\n    unregisterSlide: (slide: ComponentInternalInstance) => {\n      const slideIndex = slides.indexOf(slide)\n      if (slideIndex === -1) return\n\n      emit('slide-unregistered', { slide, index: slideIndex })\n\n      slides.splice(slideIndex, 1)\n      updateSlideIndexes(slideIndex)\n    },\n  }\n}\n\nexport type SlideRegistry = ReturnType<typeof createSlideRegistry>\n\nexport { createSlideRegistry }\n","import { cloneVNode, ComponentInternalInstance, VNode } from 'vue'\n\ntype CreateCloneSlidesArgs = {\n  slides: Array<ComponentInternalInstance>\n  position: 'before' | 'after'\n  toShow: number\n}\n\nexport function createCloneSlides({ slides, position, toShow }: CreateCloneSlidesArgs) {\n  const clones: VNode[] = []\n  const isBefore = position === 'before'\n  const start = isBefore ? -toShow : 0\n  const end = isBefore ? 0 : toShow\n\n  if (slides.length <= 0) {\n    return clones\n  }\n\n  for (let i = start; i < end; i++) {\n    const index = isBefore ? i : i + slides.length\n    const props = {\n      index,\n      isClone: true,\n      id: undefined, // Make sure we don't duplicate the id which would be invalid html\n      key: `clone-${position}-${i}`,\n    }\n    const vnode = slides[((i % slides.length) + slides.length) % slides.length].vnode\n    const clone = cloneVNode(vnode, props)\n    clone.el = null\n    clones.push(clone)\n  }\n\n  return clones\n}\n","import { VNode } from 'vue'\n\nconst FOCUSABLE_ELEMENTS_SELECTOR =\n  'a[href], button, input, textarea, select, details, [tabindex]:not([tabindex=\"-1\"])'\n\n/**\n * Disables keyboard tab navigation for all focusable child elements\n * @param node Vue virtual node containing the elements to disable\n */\nexport function disableChildrenTabbing(node: VNode) {\n  if (!node.el || !(node.el instanceof Element)) {\n    return\n  }\n\n  const elements = node.el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR)\n\n  for (const el of elements) {\n    if (\n      el instanceof HTMLElement &&\n      !el.hasAttribute('disabled') &&\n      el.getAttribute('aria-hidden') !== 'true'\n    ) {\n      el.setAttribute('tabindex', '-1')\n    }\n  }\n}\n","type GetNumberInRangeArgs = {\n  val: number\n  max: number\n  min: number\n}\n\nexport function getNumberInRange({ val, max, min }: GetNumberInRangeArgs): number {\n  if (max < min) {\n    return val\n  }\n  return Math.min(Math.max(val, isNaN(min) ? val : min), isNaN(max) ? val : max)\n}\n","// Cache for transform values to avoid repeated parsing\n// WeakMap automatically handles memory cleanup when elements are garbage collected\nconst transformCache = new WeakMap<HTMLElement, number[]>()\n\nexport function getTransformValues(el: HTMLElement) {\n  // Check cache first\n  const cached = transformCache.get(el)\n  if (cached) {\n    return cached\n  }\n\n  const { transform } = window.getComputedStyle(el)\n\n  // Handle edge cases: no transform or 'none'\n  if (!transform || transform === 'none') {\n    const result = [1, 0, 0, 1, 0, 0] // Identity matrix\n    transformCache.set(el, result)\n    return result\n  }\n\n  // Parse transform matrix\n  const values = transform\n    .split(/[(,)]/)\n    .slice(1, -1)\n    .map((v) => parseFloat(v))\n\n  // Cache the result\n  if (values.length > 0 && !values.some(isNaN)) {\n    transformCache.set(el, values)\n  }\n\n  return values\n}\n\n/**\n * Invalidates the transform cache for specific elements\n * Call this when you know transform values have changed\n *\n * Note: WeakMap doesn't have a clear() method for global invalidation.\n * If elements parameter is not provided, this function does nothing.\n */\nexport function invalidateTransformCache(elements?: Set<HTMLElement>) {\n  if (elements) {\n    elements.forEach((el) => transformCache.delete(el))\n  }\n  // Note: Cannot clear entire WeakMap - it has no clear() method\n  // Cached values will be garbage collected when elements are no longer referenced\n}\n\nexport type ScaleMultipliers = {\n  widthMultiplier: number\n  heightMultiplier: number\n}\n\nexport function getScaleMultipliers(\n  transformElements: Set<HTMLElement>\n): ScaleMultipliers {\n  // Early return if no transform elements\n  if (transformElements.size === 0) {\n    return { widthMultiplier: 1, heightMultiplier: 1 }\n  }\n\n  let widthMultiplier = 1\n  let heightMultiplier = 1\n\n  transformElements.forEach((el) => {\n    const transformArr = getTransformValues(el)\n\n    // Standard 2D transform matrix has 6 values: matrix(a, b, c, d, e, f)\n    // where a = scaleX, d = scaleY\n    if (transformArr.length === 6) {\n      const scaleX = transformArr[0]\n      const scaleY = transformArr[3]\n\n      // Avoid division by zero\n      if (scaleX !== 0) {\n        widthMultiplier /= scaleX\n      }\n      if (scaleY !== 0) {\n        heightMultiplier /= scaleY\n      }\n    }\n  })\n\n  return { widthMultiplier, heightMultiplier }\n}\n","import { SnapAlign } from '@/shared'\n\ntype SnapAlignOffsetParams = {\n  align: SnapAlign\n  slideSize?: number\n  viewportSize?: number\n  itemsToShow?: number\n}\n\n/**\n * Calculates the snap align offset for a carousel item based on items to show.\n * Returns the number of slides to offset.\n *\n * @param align - The alignment type.\n * @param itemsToShow - The number of items to show.\n * @returns The calculated offset.\n */\nfunction getSnapAlignOffsetByItemsToShow(align: SnapAlign, itemsToShow: number): number {\n  switch (align) {\n    case 'start':\n      return 0\n    case 'center':\n    case 'center-odd':\n      return (itemsToShow - 1) / 2\n    case 'center-even':\n      return (itemsToShow - 2) / 2\n    case 'end':\n      return itemsToShow - 1\n    default:\n      return 0\n  }\n}\n\n/**\n * Calculates the snap align offset for a carousel item based on slide and viewport size.\n * Returns the real width to offset.\n *\n * @param align - The alignment type.\n * @param slideSize - The size of the slide.\n * @param viewportSize - The size of the viewport.\n * @returns The calculated offset.\n */\nfunction getSnapAlignOffsetBySlideAndViewport(\n  align: SnapAlign,\n  slideSize: number,\n  viewportSize: number\n): number {\n  switch (align) {\n    case 'start':\n      return 0\n    case 'center':\n    case 'center-odd':\n      return (viewportSize - slideSize) / 2\n    case 'center-even':\n      return viewportSize / 2 - slideSize\n    case 'end':\n      return viewportSize - slideSize\n    default:\n      return 0\n  }\n}\n\n/**\n * Calculates the snap align offset for a carousel item.\n *\n * @param params - The parameters for calculating the offset.\n * @returns The calculated offset.\n */\nexport function getSnapAlignOffset({\n  slideSize,\n  viewportSize,\n  align,\n  itemsToShow,\n}: SnapAlignOffsetParams): number {\n  if (itemsToShow !== undefined) {\n    return getSnapAlignOffsetByItemsToShow(align, itemsToShow)\n  }\n  if (slideSize !== undefined && viewportSize !== undefined) {\n    return getSnapAlignOffsetBySlideAndViewport(align, slideSize, viewportSize)\n  }\n\n  return 0\n}\n","export function i18nFormatter(string = '', values = {}) {\n  return Object.entries(values).reduce(\n    (acc, [key, value]) => acc.replace(`{${key}}`, String(value)),\n    string\n  )\n}\n","type MapNumberToRangeArgs = {\n  val: number\n  max: number\n  min?: number\n}\n\nexport function mapNumberToRange({ val, max, min = 0 }: MapNumberToRangeArgs): number {\n  const mod = max - min + 1\n  return ((((val - min) % mod) + mod) % mod) + min\n}\n","/**\n * Returns a throttled version of the function using requestAnimationFrame or setTimeout.\n *\n * Uses requestAnimationFrame for immediate/frame-based throttling (ms = 0)\n * and setTimeout for longer delays to avoid unnecessary RAF calls.\n *\n * @param fn - The function to throttle.\n * @param ms - The number of milliseconds to wait for the throttled function to be called again\n */\nexport function throttle<Args extends Array<unknown>>(\n  fn: (...args: Args) => void,\n  ms = 0\n): { (...args: Args): void; cancel: () => void } {\n  let isThrottled = false\n  let timeoutId: ReturnType<typeof setTimeout> | null = null\n  let frameId: number | null = null\n\n  function throttled(...args: Args) {\n    if (isThrottled) return\n\n    isThrottled = true\n\n    // For delays longer than one frame (16ms), use setTimeout\n    // For immediate or frame-based throttling, use requestAnimationFrame\n    if (ms > 16) {\n      timeoutId = setTimeout(() => {\n        fn(...args)\n        isThrottled = false\n        timeoutId = null\n      }, ms)\n    } else {\n      frameId = requestAnimationFrame(() => {\n        fn(...args)\n        isThrottled = false\n        frameId = null\n      })\n    }\n  }\n\n  throttled.cancel = () => {\n    if (timeoutId !== null) {\n      clearTimeout(timeoutId)\n      timeoutId = null\n    }\n    if (frameId !== null) {\n      cancelAnimationFrame(frameId)\n      frameId = null\n    }\n    isThrottled = false\n  }\n\n  return throttled\n}\n","/**\n * Converts a value to a CSS-compatible string.\n * @param value - The value to convert.\n * @returns The CSS-compatible string.\n **/\nexport function toCssValue(\n  value?: string | number,\n  unit: string = 'px'\n): string | undefined {\n  if (value === null || value === undefined || value === '') {\n    return undefined\n  }\n\n  if (typeof value === 'number' || parseFloat(value).toString() === value) {\n    return `${value}${unit}`\n  }\n  return value\n}\n","import { defineComponent, h, inject } from 'vue'\n\nimport { injectCarousel } from '@/shared'\nimport { i18nFormatter } from '@/utils'\n\nexport const ARIA = defineComponent({\n  name: 'CarouselAria',\n  setup() {\n    const carousel = inject(injectCarousel)\n\n    if (!carousel) {\n      return () => ''\n    }\n\n    return () =>\n      h(\n        'div',\n        {\n          class: ['carousel__liveregion', 'carousel__sr-only'],\n          'aria-live': 'polite',\n          'aria-atomic': 'true',\n        },\n        i18nFormatter(carousel.config.i18n['itemXofY'], {\n          currentSlide: carousel.currentSlide + 1,\n          slidesCount: carousel.slidesCount,\n        })\n      )\n  },\n})\n","import { PropType } from 'vue'\n\nimport {\n  BREAKPOINT_MODE_OPTIONS,\n  DEFAULT_CONFIG,\n  DIR_MAP,\n  DIR_OPTIONS,\n  SLIDE_EFFECTS,\n  SNAP_ALIGN_OPTIONS,\n} from '@/shared'\n\nimport type {\n  BreakpointMode,\n  CarouselConfig,\n  Dir,\n  DragConfig,\n  NonNormalizedDir,\n  NormalizedDir,\n  SlideEffect,\n  SnapAlign,\n  TransitionEasing,\n  WheelConfig,\n} from '@/shared'\n\nexport const carouselProps = {\n  // time to auto advance slides in ms\n  autoplay: {\n    default: DEFAULT_CONFIG.autoplay,\n    type: Number,\n  },\n  // an object to store breakpoints\n  breakpoints: {\n    default: DEFAULT_CONFIG.breakpoints,\n    type: Object as PropType<CarouselConfig['breakpoints']>,\n  },\n  // controls the breakpoint mode relative to the carousel container or the viewport\n  breakpointMode: {\n    default: DEFAULT_CONFIG.breakpointMode,\n    validator(value: BreakpointMode) {\n      const isValid = BREAKPOINT_MODE_OPTIONS.includes(value)\n      if (!isValid) {\n        console.warn(`[vue3-carousel]: Invalid breakpointMode \"${value}\". Allowed values: ${BREAKPOINT_MODE_OPTIONS.join(', ')}`)\n      }\n      return isValid\n    },\n  },\n  clamp: {\n    type: Boolean,\n  },\n  // control the direction of the carousel\n  dir: {\n    type: String as PropType<Dir>,\n    default: DEFAULT_CONFIG.dir,\n    validator(value: Dir, props: { height?: string }) {\n      if (!DIR_OPTIONS.includes(value)) {\n        console.warn(`[vue3-carousel]: Invalid dir \"${value}\". Allowed values: ${DIR_OPTIONS.join(', ')}`)\n        return false\n      }\n      const normalizedDir = value in DIR_MAP ? DIR_MAP[value as NonNormalizedDir] : (value as NormalizedDir)\n      if ([\"ttb\", \"btt\"].includes(normalizedDir) && (!props.height || props.height === \"auto\")) {\n        console.warn(`[vue3-carousel]: The dir \"${value}\" is not supported with height \"auto\".`)\n      }\n      return true\n    },\n  },\n  // enable/disable the carousel component\n  enabled: {\n    default: DEFAULT_CONFIG.enabled,\n    type: Boolean,\n  },\n  // control the gap between slides\n  gap: {\n    default: DEFAULT_CONFIG.gap,\n    type: Number,\n  },\n  // set carousel height\n  height: {\n    default: DEFAULT_CONFIG.height,\n    type: [Number, String],\n  },\n  // aria-labels and additional text labels\n  i18n: {\n    default: DEFAULT_CONFIG.i18n,\n    type: Object as PropType<typeof DEFAULT_CONFIG.i18n>,\n  },\n  ignoreAnimations: {\n    default: false,\n    type: [Array, Boolean, String] as PropType<CarouselConfig['ignoreAnimations']>,\n  },\n  // count of items to be scrolled\n  itemsToScroll: {\n    default: DEFAULT_CONFIG.itemsToScroll,\n    type: Number,\n  },\n  // count of items to showed per view\n  itemsToShow: {\n    default: DEFAULT_CONFIG.itemsToShow,\n    type: [Number, String],\n  },\n  // slide number number of initial slide\n  modelValue: {\n    default: undefined,\n    type: Number,\n  },\n  // toggle mouse dragging\n  mouseDrag: {\n    default: DEFAULT_CONFIG.mouseDrag,\n    type: [Boolean, Object] as PropType<boolean | DragConfig>,\n  },\n  // toggle mouse wheel scrolling\n  mouseWheel: {\n    default: DEFAULT_CONFIG.mouseWheel,\n    type: [Boolean, Object] as PropType<boolean | WheelConfig>,\n  },\n  // control mouse scroll threshold\n  mouseScrollThreshold: {\n    default: DEFAULT_CONFIG.mouseScrollThreshold,\n    type: Number,\n  },\n  pauseAutoplayOnHover: {\n    default: DEFAULT_CONFIG.pauseAutoplayOnHover,\n    type: Boolean,\n  },\n  preventExcessiveDragging: {\n    default: false,\n    type: Boolean,\n    validator(value: boolean, props: { wrapAround?: boolean }) {\n      if (value && props.wrapAround) {\n        console.warn(\n          `[vue3-carousel]: \"preventExcessiveDragging\" cannot be used with wrapAround. The setting will be ignored.`\n        )\n      }\n      return true\n    },\n  },\n  slideEffect: {\n    type: String as PropType<SlideEffect>,\n    default: DEFAULT_CONFIG.slideEffect,\n    validator(value: SlideEffect) {\n      const isValid = SLIDE_EFFECTS.includes(value)\n      if (!isValid) {\n        console.warn(`[vue3-carousel]: Invalid slideEffect \"${value}\". Allowed values: ${SLIDE_EFFECTS.join(', ')}`)\n      }\n      return isValid\n    },\n  },\n  // control snap position alignment\n  snapAlign: {\n    default: DEFAULT_CONFIG.snapAlign,\n    validator(value: SnapAlign) {\n      const isValid = SNAP_ALIGN_OPTIONS.includes(value)\n      if (!isValid) {\n        console.warn(`[vue3-carousel]: Invalid snapAlign \"${value}\". Allowed values: ${SNAP_ALIGN_OPTIONS.join(', ')}`)\n      }\n      return isValid\n    },\n  },\n  // toggle touch dragging\n  touchDrag: {\n    default: DEFAULT_CONFIG.touchDrag,\n    type: [Boolean, Object] as PropType<boolean | DragConfig>,\n  },\n  // sliding transition time in ms\n  transition: {\n    default: DEFAULT_CONFIG.transition,\n    type: Number,\n  },\n  // transition easing function\n  transitionEasing: {\n    default: DEFAULT_CONFIG.transitionEasing,\n    type: String as PropType<TransitionEasing>,\n  },\n  // control infinite scrolling mode\n  wrapAround: {\n    default: DEFAULT_CONFIG.wrapAround,\n    type: Boolean,\n  },\n}\n","import {\n  ComputedRef,\n  Ref,\n  SetupContext,\n  computed,\n  defineComponent,\n  h,\n  onBeforeUnmount,\n  onMounted,\n  provide,\n  reactive,\n  ref,\n  shallowReactive,\n  toRefs,\n  watch,\n  watchEffect,\n} from 'vue'\n\nimport { ARIA as ARIAComponent } from '@/components/ARIA'\nimport { DragEventData, useDrag, useHover, useWheel, WheelEventData } from '@/composables'\nimport {\n  CarouselConfig,\n  DEFAULT_CONFIG,\n  DEFAULT_DRAG_THRESHOLD,\n  DIR_MAP,\n  NonNormalizedDir,\n  NormalizedDir,\n  createSlideRegistry,\n  injectCarousel,\n} from '@/shared'\nimport {\n  ScaleMultipliers,\n  calculateAverage,\n  createCloneSlides,\n  except,\n  getDraggedSlidesCount,\n  getNumberInRange,\n  getScaleMultipliers,\n  getSnapAlignOffset,\n  invalidateTransformCache,\n  mapNumberToRange,\n  throttle,\n  toCssValue,\n} from '@/utils'\n\nimport {\n  CarouselData,\n  CarouselExposed,\n  CarouselNav,\n  ElRect,\n  InjectedCarousel,\n} from './Carousel.types'\nimport { carouselProps } from './carouselProps'\n\nexport const Carousel = defineComponent({\n  name: 'VueCarousel',\n  props: carouselProps,\n  emits: [\n    'before-init',\n    'drag',\n    'init',\n    'loop',\n    'slide-end',\n    'slide-registered',\n    'slide-start',\n    'slide-unregistered',\n    'update:modelValue',\n    'wheel',\n  ],\n  setup(props: CarouselConfig, { slots, emit, expose }: SetupContext) {\n    const slideRegistry = createSlideRegistry(emit)\n    const slides = slideRegistry.getSlides()\n    const slidesCount = computed(() => slides.length)\n\n    const root: Ref<Element | null> = ref(null)\n    const viewport: Ref<Element | null> = ref(null)\n    const slideSize: Ref<number> = ref(0)\n\n    const fallbackConfig = computed(() => ({\n      ...DEFAULT_CONFIG,\n      // Avoid reactivity tracking in breakpoints and vModel which would trigger unnecessary updates\n      ...except(props, ['breakpoints', 'modelValue']),\n      i18n: { ...DEFAULT_CONFIG.i18n, ...props.i18n },\n    }))\n\n    // current active config\n    const config = shallowReactive<CarouselConfig>({ ...fallbackConfig.value })\n\n    // slides\n    const currentSlideIndex = ref(props.modelValue ?? 0)\n    const activeSlideIndex = ref(currentSlideIndex.value)\n\n    watch(currentSlideIndex, (val) => (activeSlideIndex.value = val))\n    const prevSlideIndex = ref(0)\n    const middleSlideIndex = computed(() => Math.ceil((slidesCount.value - 1) / 2))\n    const maxSlideIndex = computed(() => slidesCount.value - 1)\n    const minSlideIndex = computed(() => 0)\n\n    let autoplayTimer: ReturnType<typeof setInterval> | null = null\n    let transitionTimer: ReturnType<typeof setTimeout> | null = null\n    let resizeObserver: ResizeObserver | null = null\n\n    const effectiveSlideSize = computed(() => slideSize.value + config.gap)\n\n    const normalizedDir = computed<NormalizedDir>(() => {\n      const dir = config.dir || 'ltr'\n      return dir in DIR_MAP ? DIR_MAP[dir as NonNormalizedDir] : (dir as NormalizedDir)\n    })\n\n    const isReversed = computed(() => ['rtl', 'btt'].includes(normalizedDir.value))\n    const isVertical = computed(() => ['ttb', 'btt'].includes(normalizedDir.value))\n    const isAuto = computed(() => config.itemsToShow === 'auto')\n\n    const dimension = computed(() => (isVertical.value ? 'height' : 'width'))\n\n    function updateBreakpointsConfig(): void {\n      if (!mounted.value) {\n        return\n      }\n      // Determine the width source based on the 'breakpointMode' config\n      const widthSource =\n        (fallbackConfig.value.breakpointMode === 'carousel'\n          ? root.value?.getBoundingClientRect().width\n          : typeof window !== 'undefined'\n            ? window.innerWidth\n            : 0) || 0\n\n      const breakpointsArray = Object.keys(props.breakpoints || {})\n        .map((key) => Number(key))\n        .sort((a, b) => +b - +a)\n\n      const newConfig: Partial<CarouselConfig> = {}\n      breakpointsArray.some((breakpoint) => {\n        if (widthSource >= breakpoint) {\n          Object.assign(newConfig, props.breakpoints![breakpoint])\n          if (newConfig.i18n) {\n            Object.assign(\n              newConfig.i18n,\n              fallbackConfig.value.i18n,\n              props.breakpoints![breakpoint].i18n\n            )\n          }\n          return true\n        }\n        return false\n      })\n\n      Object.assign(config, fallbackConfig.value, newConfig)\n\n      // Validate itemsToShow\n      if (!isAuto.value) {\n        config.itemsToShow = getNumberInRange({\n          val: Number(config.itemsToShow),\n          max: props.clamp ? slidesCount.value : Infinity,\n          min: 1,\n        })\n      }\n    }\n\n    const handleResize = throttle(() => {\n      updateBreakpointsConfig()\n      updateSlidesData()\n      updateSlideSize()\n    })\n\n    const transformElements = shallowReactive<Set<HTMLElement>>(new Set())\n\n    /**\n     * Setup functions\n     */\n    const slidesRect = ref<Array<ElRect>>([])\n    function updateSlidesRectSize({\n      widthMultiplier,\n      heightMultiplier,\n    }: ScaleMultipliers): void {\n      slidesRect.value = slides.map((slide) => {\n        const rect = slide.exposed?.getBoundingRect()\n        return {\n          width: rect.width * widthMultiplier,\n          height: rect.height * heightMultiplier,\n        }\n      })\n    }\n    const viewportRect: Ref<ElRect> = ref({\n      width: 0,\n      height: 0,\n    })\n    function updateViewportRectSize({\n      widthMultiplier,\n      heightMultiplier,\n    }: ScaleMultipliers): void {\n      const rect = viewport.value?.getBoundingClientRect() || { width: 0, height: 0 }\n      viewportRect.value = {\n        width: rect.width * widthMultiplier,\n        height: rect.height * heightMultiplier,\n      }\n    }\n\n    function updateSlideSize(): void {\n      if (!viewport.value) return\n\n      const scaleMultipliers = getScaleMultipliers(transformElements)\n\n      updateViewportRectSize(scaleMultipliers)\n      updateSlidesRectSize(scaleMultipliers)\n\n      if (isAuto.value) {\n        slideSize.value = calculateAverage(\n          slidesRect.value.map((slide) => slide[dimension.value])\n        )\n      } else {\n        const itemsToShow = Number(config.itemsToShow)\n        const totalGap = (itemsToShow - 1) * config.gap\n        slideSize.value = (viewportRect.value[dimension.value] - totalGap) / itemsToShow\n      }\n    }\n\n    function updateSlidesData(): void {\n      if (!config.wrapAround && slidesCount.value > 0) {\n        currentSlideIndex.value = getNumberInRange({\n          val: currentSlideIndex.value,\n          max: maxSlideIndex.value,\n          min: minSlideIndex.value,\n        })\n      }\n    }\n\n    const ignoreAnimations = computed<false | string[]>(() => {\n      if (typeof props.ignoreAnimations === 'string') {\n        return props.ignoreAnimations.split(',')\n      } else if (Array.isArray(props.ignoreAnimations)) {\n        return props.ignoreAnimations\n      } else if (!props.ignoreAnimations) {\n        return []\n      }\n      return false\n    })\n\n    watchEffect(() => updateSlidesData())\n\n    watchEffect(() => {\n      // Call updateSlideSize when viewport is ready and track deps\n      updateSlideSize()\n    })\n\n    let animationInterval: number\n\n    const setAnimationInterval = (event: AnimationEvent) => {\n      const target = event.target as HTMLElement\n      if (\n        !target?.contains(root.value) ||\n        (Array.isArray(ignoreAnimations.value) &&\n          ignoreAnimations.value.includes(event.animationName))\n      ) {\n        return\n      }\n\n      transformElements.add(target)\n      // Invalidate transform cache for this element as it's animating\n      invalidateTransformCache(new Set([target]))\n\n      if (!animationInterval) {\n        const stepAnimation = () => {\n          animationInterval = requestAnimationFrame(() => {\n            // Invalidate cache during animation to get fresh values\n            invalidateTransformCache(transformElements)\n            updateSlideSize()\n            stepAnimation()\n          })\n        }\n        stepAnimation()\n      }\n    }\n    const finishAnimation = (event: AnimationEvent | TransitionEvent) => {\n      const target = event.target as HTMLElement\n      if (target) {\n        transformElements.delete(target)\n        // Invalidate cache one final time after animation completes\n        invalidateTransformCache(new Set([target]))\n      }\n      if (animationInterval && transformElements.size === 0) {\n        cancelAnimationFrame(animationInterval)\n        updateSlideSize()\n      }\n    }\n\n    const mounted = ref(false)\n\n    if (typeof document !== 'undefined') {\n      watchEffect(() => {\n        if (mounted.value && ignoreAnimations.value !== false) {\n          // Use passive listeners for better performance\n          document.addEventListener('animationstart', setAnimationInterval, { passive: true })\n          document.addEventListener('animationend', finishAnimation, { passive: true })\n        } else {\n          document.removeEventListener('animationstart', setAnimationInterval)\n          document.removeEventListener('animationend', finishAnimation)\n        }\n      })\n    }\n\n    onMounted((): void => {\n      mounted.value = true\n      updateBreakpointsConfig()\n      initAutoplay()\n\n      if (root.value) {\n        resizeObserver = new ResizeObserver(handleResize)\n        resizeObserver.observe(root.value)\n      }\n\n      emit('init')\n    })\n\n    onBeforeUnmount(() => {\n      mounted.value = false\n\n      slideRegistry.cleanup()\n\n      if (transitionTimer) {\n        clearTimeout(transitionTimer)\n      }\n      if (animationInterval) {\n        cancelAnimationFrame(animationInterval)\n      }\n      if (autoplayTimer) {\n        clearInterval(autoplayTimer)\n      }\n      if (resizeObserver) {\n        resizeObserver.disconnect()\n        resizeObserver = null\n      }\n\n      if (typeof document !== 'undefined') {\n        handleBlur()\n      }\n      if (root.value) {\n        root.value.removeEventListener('transitionend', updateSlideSize)\n        root.value.removeEventListener('animationiteration', updateSlideSize)\n      }\n    })\n\n    /**\n     * Carousel Event listeners\n     */\n    const { isHover, handleMouseEnter, handleMouseLeave } = useHover()\n\n    const handleArrowKeys = throttle((event: KeyboardEvent): void => {\n      if (event.ctrlKey) return\n      switch (event.key) {\n        case 'ArrowLeft':\n        case 'ArrowUp':\n          if (isVertical.value === event.key.endsWith('Up')) {\n            if (isReversed.value) {\n              next(true)\n            } else {\n              prev(true)\n            }\n          }\n          break\n        case 'ArrowRight':\n        case 'ArrowDown':\n          if (isVertical.value === event.key.endsWith('Down')) {\n            if (isReversed.value) {\n              prev(true)\n            } else {\n              next(true)\n            }\n          }\n          break\n      }\n    }, 200)\n\n    const handleBlur = (): void => {\n      document.removeEventListener('keydown', handleArrowKeys)\n    }\n\n    const handleFocus = (): void => {\n      document.addEventListener('keydown', handleArrowKeys)\n    }\n\n    /**\n     * Autoplay\n     */\n    function initAutoplay(): void {\n      if (!config.autoplay || config.autoplay <= 0) {\n        return\n      }\n\n      autoplayTimer = setInterval(() => {\n        if (config.pauseAutoplayOnHover && isHover.value) {\n          return\n        }\n\n        next()\n      }, config.autoplay)\n    }\n\n    function resetAutoplay(): void {\n      stopAutoplay()\n      initAutoplay()\n    }\n\n    function stopAutoplay(): void {\n      if (autoplayTimer) {\n        clearInterval(autoplayTimer)\n        autoplayTimer = null\n      }\n    }\n\n    /**\n     * Navigation function\n     */\n    const isSliding = ref(false)\n\n    const onDrag = ({ deltaX, deltaY, isTouch }: DragEventData) => {\n      emit('drag', { deltaX, deltaY })\n\n      const threshold = isTouch\n        ? typeof config.touchDrag === 'object'\n          ? (config.touchDrag?.threshold ?? DEFAULT_DRAG_THRESHOLD)\n          : DEFAULT_DRAG_THRESHOLD\n        : typeof config.mouseDrag === 'object'\n          ? (config.mouseDrag?.threshold ?? DEFAULT_DRAG_THRESHOLD)\n          : DEFAULT_DRAG_THRESHOLD\n\n      const draggedSlides = getDraggedSlidesCount({\n        isVertical: isVertical.value,\n        isReversed: isReversed.value,\n        dragged: { x: deltaX, y: deltaY },\n        effectiveSlideSize: effectiveSlideSize.value,\n        threshold,\n      })\n\n      // Prevent unnecessary reactivity\n      if (draggedSlides === 0) {\n        return\n      }\n\n      activeSlideIndex.value = config.wrapAround\n        ? currentSlideIndex.value + draggedSlides\n        : getNumberInRange({\n            val: currentSlideIndex.value + draggedSlides,\n            max: maxSlideIndex.value,\n            min: minSlideIndex.value,\n          })\n    }\n\n    const onDragEnd = () => slideTo(activeSlideIndex.value)\n\n    const { dragged, isDragging, handleDragStart } = useDrag({\n      isSliding,\n      onDrag,\n      onDragEnd,\n    })\n\n    const onWheel = ({ deltaX, deltaY, isScrollingForward }: WheelEventData) => {\n      emit('wheel', { deltaX, deltaY })\n\n      if (isScrollingForward) {\n        // Scrolling down/right\n        if (isReversed.value) {\n          prev()\n        } else {\n          next()\n        }\n      } else {\n        // Scrolling up/left\n        if (isReversed.value) {\n          next()\n        } else {\n          prev()\n        }\n      }\n    }\n\n    const { handleScroll } = useWheel({\n      isVertical,\n      isSliding,\n      config,\n      onWheel,\n    })\n\n    function next(skipTransition = false): void {\n      slideTo(currentSlideIndex.value + config.itemsToScroll, skipTransition)\n    }\n\n    function prev(skipTransition = false): void {\n      slideTo(currentSlideIndex.value - config.itemsToScroll, skipTransition)\n    }\n\n    function slideTo(slideIndex: number, skipTransition = false): void {\n      if (!skipTransition && isSliding.value) {\n        return\n      }\n      \n      const targetIndex = (config.wrapAround ? mapNumberToRange : getNumberInRange)({\n        val: slideIndex,\n        max: maxSlideIndex.value,\n        min: minSlideIndex.value,\n      })\n      \n      if (currentSlideIndex.value === targetIndex) {\n        return;\n      }\n      \n      prevSlideIndex.value = currentSlideIndex.value\n\n      emit('slide-start', {\n        slidingToIndex: slideIndex,\n        currentSlideIndex: currentSlideIndex.value,\n        prevSlideIndex: prevSlideIndex.value,\n        slidesCount: slidesCount.value,\n      })\n\n      stopAutoplay()\n      isSliding.value = true\n\n      currentSlideIndex.value = slideIndex\n      if (targetIndex !== slideIndex) {\n        modelWatcher.pause()\n      }\n      emit('update:modelValue', targetIndex)\n\n      const transitionCallback = (): void => {\n        if (config.wrapAround && targetIndex !== slideIndex) {\n          modelWatcher.resume()\n\n          currentSlideIndex.value = targetIndex\n          emit('loop', {\n            currentSlideIndex: currentSlideIndex.value,\n            slidingToIndex: slideIndex,\n          })\n        }\n\n        emit('slide-end', {\n          currentSlideIndex: currentSlideIndex.value,\n          prevSlideIndex: prevSlideIndex.value,\n          slidesCount: slidesCount.value,\n        })\n\n        isSliding.value = false\n        resetAutoplay()\n      }\n\n      transitionTimer = setTimeout(transitionCallback, config.transition)\n    }\n\n    function restartCarousel(): void {\n      updateBreakpointsConfig()\n      updateSlidesData()\n      updateSlideSize()\n      resetAutoplay()\n    }\n\n    // Update the carousel on props change\n    watch(\n      () => [fallbackConfig.value, props.breakpoints],\n      () => updateBreakpointsConfig(),\n      { deep: true }\n    )\n\n    watch(\n      () => props.autoplay,\n      () => resetAutoplay()\n    )\n\n    // Handle changing v-model value\n    const modelWatcher = watch(\n      () => props.modelValue,\n      (val) => {\n        if (val === currentSlideIndex.value) {\n          return\n        }\n        slideTo(Number(val), true)\n      }\n    )\n\n    // Init carousel\n    emit('before-init')\n\n    const clonedSlidesCount = computed(() => {\n      if (!config.wrapAround) {\n        return { before: 0, after: 0 }\n      }\n      if (isAuto.value) {\n        return { before: slides.length, after: slides.length }\n      }\n\n      const itemsToShow = Number(config.itemsToShow)\n      const slidesToClone = Math.ceil(itemsToShow + (config.itemsToScroll - 1))\n      const before = slidesToClone - activeSlideIndex.value\n      const after = slidesToClone - (slidesCount.value - (activeSlideIndex.value + 1))\n\n      return {\n        before: Math.max(0, before),\n        after: Math.max(0, after),\n      }\n    })\n\n    const clonedSlidesOffset = computed(() => {\n      if (!clonedSlidesCount.value.before) {\n        return 0\n      }\n      if (isAuto.value) {\n        return (\n          slidesRect.value\n            .slice(-1 * clonedSlidesCount.value.before)\n            .reduce((acc, slide) => acc + slide[dimension.value] + config.gap, 0) * -1\n        )\n      }\n\n      return clonedSlidesCount.value.before * effectiveSlideSize.value * -1\n    })\n\n    const snapAlignOffset = computed(() => {\n      if (isAuto.value) {\n        const slideIndex =\n          ((currentSlideIndex.value % slides.length) + slides.length) % slides.length\n        return getSnapAlignOffset({\n          slideSize: slidesRect.value[slideIndex]?.[dimension.value],\n          viewportSize: viewportRect.value[dimension.value],\n          align: config.snapAlign,\n        })\n      }\n\n      return getSnapAlignOffset({\n        align: config.snapAlign,\n        itemsToShow: +config.itemsToShow,\n      })\n    })\n    const scrolledOffset = computed(() => {\n      let output = 0\n\n      if (isAuto.value) {\n        if (currentSlideIndex.value < 0) {\n          output =\n            slidesRect.value\n              .slice(currentSlideIndex.value)\n              .reduce((acc, slide) => acc + slide[dimension.value] + config.gap, 0) * -1\n        } else {\n          output = slidesRect.value\n            .slice(0, currentSlideIndex.value)\n            .reduce((acc, slide) => acc + slide[dimension.value] + config.gap, 0)\n        }\n        output -= snapAlignOffset.value\n\n        // remove whitespace\n        if (!config.wrapAround) {\n          const maxSlidingValue =\n            slidesRect.value.reduce(\n              (acc, slide) => acc + slide[dimension.value] + config.gap,\n              0\n            ) -\n            viewportRect.value[dimension.value] -\n            config.gap\n\n          output = getNumberInRange({\n            val: output,\n            max: maxSlidingValue,\n            min: 0,\n          })\n        }\n      } else {\n        let scrolledSlides = currentSlideIndex.value - snapAlignOffset.value\n\n        // remove whitespace\n        if (!config.wrapAround) {\n          scrolledSlides = getNumberInRange({\n            val: scrolledSlides,\n            max: slidesCount.value - +config.itemsToShow,\n            min: 0,\n          })\n        }\n        output = scrolledSlides * effectiveSlideSize.value\n      }\n\n      return output * (isReversed.value ? 1 : -1)\n    })\n\n    const visibleRange = computed(() => {\n      if (!isAuto.value) {\n        const base = currentSlideIndex.value - snapAlignOffset.value\n        if (config.wrapAround) {\n          return {\n            min: Math.floor(base),\n            max: Math.ceil(base + Number(config.itemsToShow) - 1),\n          }\n        }\n        return {\n          min: Math.floor(\n            getNumberInRange({\n              val: base,\n              max: slidesCount.value - Number(config.itemsToShow),\n              min: 0,\n            })\n          ),\n          max: Math.ceil(\n            getNumberInRange({\n              val: base + Number(config.itemsToShow) - 1,\n              max: slidesCount.value - 1,\n              min: 0,\n            })\n          ),\n        }\n      }\n\n      // Auto width mode\n      let minIndex = 0\n      {\n        let accumulatedSize = 0\n        let index = 0 - clonedSlidesCount.value.before\n        const offset = Math.abs(scrolledOffset.value + clonedSlidesOffset.value)\n        let iterations = 0\n        const maxIterations = slides.length * 2\n\n        while (accumulatedSize <= offset && iterations < maxIterations) {\n          const normalizedIndex =\n            ((index % slides.length) + slides.length) % slides.length\n          const slideSize = slidesRect.value[normalizedIndex]?.[dimension.value] || 0\n          if (slideSize <= 0) break\n          accumulatedSize += slideSize + config.gap\n          index++\n          iterations++\n        }\n        minIndex = index - 1\n      }\n\n      let maxIndex = 0\n      {\n        let index = minIndex\n        let accumulatedSize = 0\n        let iterations = 0\n        const maxIterations = slides.length * 2\n        \n        if (index < 0) {\n          accumulatedSize =\n            slidesRect.value\n              .slice(0, index)\n              .reduce((acc, slide) => acc + slide[dimension.value] + config.gap, 0) -\n            Math.abs(scrolledOffset.value + clonedSlidesOffset.value)\n        } else {\n          accumulatedSize =\n            slidesRect.value\n              .slice(0, index)\n              .reduce((acc, slide) => acc + slide[dimension.value] + config.gap, 0) -\n            Math.abs(scrolledOffset.value)\n        }\n\n        while (accumulatedSize < viewportRect.value[dimension.value] && iterations < maxIterations) {\n          const normalizedIndex =\n            ((index % slides.length) + slides.length) % slides.length\n          const slideSize = slidesRect.value[normalizedIndex]?.[dimension.value] || 0\n          if (slideSize <= 0) break\n          accumulatedSize += slideSize + config.gap\n          index++\n          iterations++\n        }\n        maxIndex = index - 1\n      }\n\n      return {\n        min: Math.floor(minIndex),\n        max: Math.ceil(maxIndex),\n      }\n    })\n\n    const trackTransform: ComputedRef<string | undefined> = computed(() => {\n      if (config.slideEffect === 'fade') {\n        return undefined\n      }\n\n      const translateAxis = isVertical.value ? 'Y' : 'X'\n\n      // Include user drag interaction offset\n      const dragOffset = isVertical.value ? dragged.y : dragged.x\n\n      let totalOffset = scrolledOffset.value + dragOffset\n\n      if (!config.wrapAround && config.preventExcessiveDragging) {\n        let maxSlidingValue = 0\n        if (isAuto.value) {\n          maxSlidingValue = slidesRect.value.reduce(\n            (acc, slide) => acc + slide[dimension.value],\n            0\n          )\n        } else {\n          maxSlidingValue =\n            (slidesCount.value - Number(config.itemsToShow)) * effectiveSlideSize.value\n        }\n        const min = isReversed.value ? 0 : -1 * maxSlidingValue\n        const max = isReversed.value ? maxSlidingValue : 0\n        totalOffset = getNumberInRange({\n          val: totalOffset,\n          min,\n          max,\n        })\n      }\n      return `translate${translateAxis}(${totalOffset}px)`\n    })\n\n    const carouselStyle = computed(() => ({\n      '--vc-carousel-height': toCssValue(config.height),\n      '--vc-cloned-offset': toCssValue(clonedSlidesOffset.value),\n      '--vc-slide-gap': toCssValue(config.gap),\n      '--vc-transition-duration': isSliding.value\n        ? toCssValue(config.transition, 'ms')\n        : undefined,\n      '--vc-transition-easing': config.transitionEasing,\n    }))\n\n    const nav: CarouselNav = { slideTo, next, prev }\n\n    const provided: InjectedCarousel = reactive({\n      activeSlide: activeSlideIndex,\n      config,\n      currentSlide: currentSlideIndex,\n      isSliding,\n      isVertical,\n      maxSlide: maxSlideIndex,\n      minSlide: minSlideIndex,\n      nav,\n      normalizedDir,\n      slideRegistry,\n      slideSize,\n      slides,\n      slidesCount,\n      viewport,\n      visibleRange,\n    })\n\n    provide(injectCarousel, provided)\n\n    const data = reactive<CarouselData>({\n      config,\n      currentSlide: currentSlideIndex,\n      maxSlide: maxSlideIndex,\n      middleSlide: middleSlideIndex,\n      minSlide: minSlideIndex,\n      slideSize,\n      slidesCount,\n    })\n\n    expose<CarouselExposed>(\n      reactive({\n        data,\n        next,\n        prev,\n        restartCarousel,\n        slideTo,\n        updateBreakpointsConfig,\n        updateSlideSize,\n        updateSlidesData,\n        ...toRefs(provided),\n      })\n    )\n\n    return () => {\n      const slotSlides = slots.default || slots.slides\n      const outputSlides = slotSlides?.(data) || []\n\n      const { before, after } = clonedSlidesCount.value\n      const slidesBefore = createCloneSlides({\n        slides,\n        position: 'before',\n        toShow: before,\n      })\n\n      const slidesAfter = createCloneSlides({\n        slides,\n        position: 'after',\n        toShow: after,\n      })\n\n      const output = [...slidesBefore, ...outputSlides, ...slidesAfter]\n\n      if (!config.enabled || !output.length) {\n        return h(\n          'section',\n          {\n            ref: root,\n            class: ['carousel', 'is-disabled'],\n          },\n          output\n        )\n      }\n\n      const addonsElements = slots.addons?.(data) || []\n\n      const trackEl = h(\n        'ol',\n        {\n          class: 'carousel__track',\n          onMousedownCapture: config.mouseDrag ? handleDragStart : null,\n          onTouchstartPassiveCapture: config.touchDrag ? handleDragStart : null,\n          onWheel: config.mouseWheel ? handleScroll : null,\n          style: { transform: trackTransform.value },\n        },\n        output\n      )\n      const viewPortEl = h('div', { class: 'carousel__viewport', ref: viewport }, trackEl)\n\n      return h(\n        'section',\n        {\n          ref: root,\n          class: [\n            'carousel',\n            `is-${normalizedDir.value}`,\n            `is-effect-${config.slideEffect}`,\n            {\n              'is-dragging': isDragging.value,\n              'is-hover': isHover.value,\n              'is-sliding': isSliding.value,\n              'is-vertical': isVertical.value,\n            },\n          ],\n          dir: normalizedDir.value,\n          style: carouselStyle.value,\n          'aria-label': config.i18n['ariaGallery'],\n          tabindex: '0',\n          onBlur: handleBlur,\n          onFocus: handleFocus,\n          onMouseenter: handleMouseEnter,\n          onMouseleave: handleMouseLeave,\n        },\n        [viewPortEl, addonsElements, h(ARIAComponent)]\n      )\n    }\n  },\n})\n","\n/** Useful function to destructure props without triggering reactivity for certain keys */\nexport function except<Obj extends object, Keys extends string>(obj: Obj, keys: Keys[]): Omit<Obj, Keys> {\n  return (Object.keys(obj).filter((k) => !(keys as string[]).includes(k)) as Array<Exclude<keyof Obj, Keys>>)\n    .reduce((acc, key) => (acc[key] = obj[key], acc), {} as Omit<Obj, Keys>)\n}","export function calculateAverage(numbers: number[]) {\n  if (numbers.length === 0) return 0\n  const validNumbers = numbers.filter(num => typeof num === 'number' && !isNaN(num) && isFinite(num))\n  if (validNumbers.length === 0) return 0\n  const sum = validNumbers.reduce((acc, num) => acc + num, 0)\n  return sum / validNumbers.length\n}\n","import { ref } from 'vue'\n\nexport function useHover() {\n  const isHover = ref(false)\n\n  const handleMouseEnter = (): void => {\n    isHover.value = true\n  }\n\n  const handleMouseLeave = (): void => {\n    isHover.value = false\n  }\n\n  return {\n    isHover,\n    handleMouseEnter,\n    handleMouseLeave,\n  }\n}\n","import { ref, reactive, computed, Ref } from 'vue'\n\nimport { throttle } from '@/utils'\n\nexport type DragEventData = {\n  deltaX: number\n  deltaY: number\n  isTouch: boolean\n}\nexport interface UseDragOptions {\n  isSliding: boolean | Ref<boolean>\n  onDrag?: ({ deltaX, deltaY, isTouch }: DragEventData) => void\n  onDragStart?: () => void\n  onDragEnd?: () => void\n}\n\nexport function useDrag(options: UseDragOptions) {\n  let isTouch = false\n  const startPosition = { x: 0, y: 0 }\n  const dragged = reactive({ x: 0, y: 0 })\n  const isDragging = ref(false)\n\n  const { isSliding } = options\n\n  const sliding = computed(() => {\n    return typeof isSliding === 'boolean' ? isSliding : isSliding.value\n  })\n\n  const handleDragStart = (event: MouseEvent | TouchEvent): void => {\n    // Prevent drag initiation on input elements or if already sliding\n    const targetTagName = (event.target as HTMLElement).tagName\n    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(targetTagName) || sliding.value) {\n      return\n    }\n\n    isTouch = event.type === 'touchstart'\n\n    if (isTouch && (event as TouchEvent).touches.length > 1) {\n      // If there is more than 1 finger on the screen, avoid drag start (this allows user to pinch zoom)\n      return\n    } else if (!isTouch) {\n      event.preventDefault()\n      if ((event as MouseEvent).button !== 0) {\n        return\n      }\n    }\n\n    startPosition.x = isTouch\n      ? (event as TouchEvent).touches[0].clientX\n      : (event as MouseEvent).clientX\n    startPosition.y = isTouch\n      ? (event as TouchEvent).touches[0].clientY\n      : (event as MouseEvent).clientY\n\n    const moveEvent = isTouch ? 'touchmove' : 'mousemove'\n    const endEvent = isTouch ? 'touchend' : 'mouseup'\n    document.addEventListener(moveEvent, handleDrag, { passive: isTouch })\n    document.addEventListener(endEvent, handleDragEnd, { passive: true })\n\n    options.onDragStart?.()\n  }\n\n  const handleDrag = throttle((event: TouchEvent | MouseEvent): void => {\n    if (isTouch && (event as TouchEvent).touches.length > 1) {\n      return\n    }\n\n    isDragging.value = true\n\n    const currentX = isTouch\n      ? (event as TouchEvent).touches[0].clientX\n      : (event as MouseEvent).clientX\n    const currentY = isTouch\n      ? (event as TouchEvent).touches[0].clientY\n      : (event as MouseEvent).clientY\n\n    dragged.x = currentX - startPosition.x\n    dragged.y = currentY - startPosition.y\n\n    options.onDrag?.({ deltaX: dragged.x, deltaY: dragged.y, isTouch })\n  })\n\n  const handleDragEnd = (): void => {\n    handleDrag.cancel()\n\n    const draggedDistance = Math.abs(dragged.x) + Math.abs(dragged.y);\n\n    if (!isTouch && draggedDistance > 10) {\n      window.addEventListener('click', (e: MouseEvent) => {\n        e.preventDefault()\n        e.stopPropagation()\n      }, { once: true, capture: true })\n    }\n\n    options.onDragEnd?.()\n\n    dragged.x = 0\n    dragged.y = 0\n    isDragging.value = false\n\n    const moveEvent = isTouch ? 'touchmove' : 'mousemove'\n    const endEvent = isTouch ? 'touchend' : 'mouseup'\n    document.removeEventListener(moveEvent, handleDrag)\n    document.removeEventListener(endEvent, handleDragEnd)\n  }\n\n  return {\n    dragged,\n    isDragging,\n    handleDragStart,\n  }\n}\n","type DragParams = {\n  isVertical: boolean\n  isReversed: boolean\n  dragged: { x: number; y: number }\n  effectiveSlideSize: number\n  threshold: number\n}\n\n/**\n * Calculates the number of slides to move based on drag movement\n * @param params Configuration parameters for drag calculation\n * @returns Number of slides to move (positive or negative)\n */\nexport function getDraggedSlidesCount(params: DragParams): number {\n  const { isVertical, isReversed, dragged, effectiveSlideSize, threshold } = params\n\n  // Get drag value based on direction\n  const dragValue = isVertical ? dragged.y : dragged.x\n\n  // If no drag, return +0 explicitly\n  if (dragValue === 0) return 0\n\n  const dragRatio = dragValue / effectiveSlideSize\n  const absRatio = Math.abs(dragRatio)\n\n  // If below the threshold, consider it no movement\n  if (absRatio < threshold) return 0\n  \n  // For drags less than a full slide, move one slide in the drag direction\n  // For drags of a full slide or more, move the corresponding number of slides\n  const slidesDragged = absRatio < 1 ? Math.sign(dragRatio) : Math.round(dragRatio)\n\n  return isReversed ? slidesDragged : -slidesDragged\n}\n","import { ComputedRef, Ref, computed } from 'vue'\n\nimport { CarouselConfig } from '@/shared'\nimport { DEFAULT_MOUSE_WHEEL_THRESHOLD } from '@/shared/constants'\n\nexport type WheelEventData = {\n  deltaX: number\n  deltaY: number\n  isScrollingForward: boolean\n}\n\nexport type UseWheelOptions = {\n  isVertical: boolean | ComputedRef<boolean>\n  isSliding: boolean | Ref<boolean>\n  config: CarouselConfig\n  onWheel?: (data: WheelEventData) => void\n}\n\nexport function useWheel(options: UseWheelOptions) {\n  const { isVertical, isSliding, config } = options\n\n  // Create computed values to handle both reactive and non-reactive inputs\n  const vertical = computed(() => {\n    return typeof isVertical === 'boolean' ? isVertical : isVertical.value\n  })\n\n  const sliding = computed(() => {\n    return typeof isSliding === 'boolean' ? isSliding : isSliding.value\n  })\n\n  const handleScroll = (event: WheelEvent): void => {\n    event.preventDefault()\n\n    if (!config.mouseWheel || sliding.value) {\n      return\n    }\n\n    // Add sensitivity threshold to prevent small movements from triggering navigation\n    const threshold =\n      typeof config.mouseWheel === 'object'\n        ? (config.mouseWheel.threshold ?? DEFAULT_MOUSE_WHEEL_THRESHOLD)\n        : DEFAULT_MOUSE_WHEEL_THRESHOLD\n\n    // Determine scroll direction\n    const deltaY = Math.abs(event.deltaY) > threshold ? event.deltaY : 0\n    const deltaX = Math.abs(event.deltaX) > threshold ? event.deltaX : 0\n\n    // If neither delta exceeds the threshold, don't navigate\n    if (deltaY === 0 && deltaX === 0) {\n      return\n    }\n\n    // Determine primary delta based on carousel orientation\n    const primaryDelta = vertical.value ? deltaY : deltaX\n\n    // If primaryDelta is 0, use the other delta as fallback\n    const effectiveDelta =\n      primaryDelta !== 0 ? primaryDelta : vertical.value ? deltaX : deltaY\n\n    // Positive delta means scrolling down/right\n    const isScrollingForward = effectiveDelta > 0\n\n    options.onWheel?.({ deltaX, deltaY, isScrollingForward })\n  }\n\n  return {\n    handleScroll,\n  }\n}\n","export enum IconName {\n  arrowDown = 'arrowDown',\n  arrowLeft = 'arrowLeft',\n  arrowRight = 'arrowRight',\n  arrowUp = 'arrowUp',\n}\n\nexport type IconNameValue = `${IconName}`\n\nexport type IconProps = {\n  name: IconNameValue\n  title?: string\n}\n","import { defineComponent, h, inject, PropType } from 'vue'\n\nimport { DEFAULT_CONFIG, injectCarousel } from '@/shared'\n\nimport { IconName, IconNameValue, IconProps } from './Icon.types'\n\nconst iconI18n = <Name extends IconNameValue>(name: Name) =>\n  `icon${name.charAt(0).toUpperCase() + name.slice(1)}` as `icon${Capitalize<Name>}`\n\nexport const icons = {\n  arrowDown: 'M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z',\n  arrowLeft: 'M15.41 16.59L10.83 12l4.58-4.59L14 6l-6 6 6 6 1.41-1.41z',\n  arrowRight: 'M8.59 16.59L13.17 12 8.59 7.41 10 6l6 6-6 6-1.41-1.41z',\n  arrowUp: 'M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z',\n}\n\nfunction isIconName(candidate: string): candidate is IconName {\n  return candidate in IconName\n}\n\nconst validateIconName = (value: IconNameValue) => {\n  return value && isIconName(value)\n}\n\nexport const Icon = defineComponent<IconProps>({\n  props: {\n    name: {\n      type: String as PropType<IconNameValue>,\n      required: true,\n      validator: validateIconName,\n    },\n    title: {\n      type: String,\n      default: (props: { name: IconNameValue }) =>\n        props.name ? DEFAULT_CONFIG.i18n[iconI18n(props.name)] : '',\n    },\n  },\n  setup(props) {\n    const carousel = inject(injectCarousel, null)\n\n    return () => {\n      const iconName = props.name\n      if (!iconName || !validateIconName(iconName)) return\n\n      const path = icons[iconName]\n      const pathEl = h('path', { d: path })\n\n      const iconTitle: string = carousel?.config.i18n[iconI18n(iconName)] || props.title!\n\n      const titleEl = h('title', iconTitle)\n\n      return h(\n        'svg',\n        {\n          class: 'carousel__icon',\n          viewBox: '0 0 24 24',\n          role: 'img',\n          'aria-label': iconTitle,\n        },\n        [titleEl, pathEl]\n      )\n    }\n  },\n})\n","import { computed, defineComponent, h, inject, PropType } from 'vue'\n\nimport { injectCarousel, NormalizedDir } from '@/shared'\n\nimport { Icon, IconNameValue } from '../Icon'\n\nimport { NavigationProps } from './Navigation.types'\n\nexport const Navigation = defineComponent<NavigationProps>({\n  name: 'CarouselNavigation',\n  inheritAttrs: false,\n  props: {\n    carousel: {\n      type: Object as PropType<NavigationProps['carousel']>,\n    },\n  },\n  setup(props, { slots, attrs }) {\n    let carousel = inject(injectCarousel, null)!\n    const { next: slotNext, prev: slotPrev } = slots\n\n    const getPrevIcon = () => {\n      const directionIcons: Record<NormalizedDir, IconNameValue> = {\n        btt: 'arrowDown',\n        ltr: 'arrowLeft',\n        rtl: 'arrowRight',\n        ttb: 'arrowUp',\n      }\n\n      return directionIcons[carousel.normalizedDir]\n    }\n    const getNextIcon = () => {\n      const directionIcons: Record<NormalizedDir, IconNameValue> = {\n        btt: 'arrowUp',\n        ltr: 'arrowRight',\n        rtl: 'arrowLeft',\n        ttb: 'arrowDown',\n      }\n\n      return directionIcons[carousel.normalizedDir]\n    }\n\n    const prevDisabled = computed(\n      () => !carousel.config.wrapAround && carousel.currentSlide <= carousel.minSlide\n    )\n    const nextDisabled = computed(\n      () => !carousel.config.wrapAround && carousel.currentSlide >= carousel.maxSlide\n    )\n\n    return () => {\n      if (props.carousel) {\n        carousel = props.carousel;\n      }\n      if (!carousel) {\n        console.warn('[vue3-carousel]: A carousel component must be provided for the navigation component to display')\n        return '';\n      }\n      const { i18n } = carousel.config\n      const prevButton = h(\n        'button',\n        {\n          type: 'button',\n          disabled: prevDisabled.value,\n          'aria-label': i18n['ariaPreviousSlide'],\n          title: i18n['ariaPreviousSlide'],\n          onClick: carousel.nav.prev,\n          ...attrs,\n          class: [\n            'carousel__prev',\n            { 'carousel__prev--disabled': prevDisabled.value },\n            attrs.class,\n          ],\n        },\n        slotPrev?.() || h(Icon, { name: getPrevIcon() })\n      )\n      const nextButton = h(\n        'button',\n        {\n          type: 'button',\n          disabled: nextDisabled.value,\n          'aria-label': i18n['ariaNextSlide'],\n          title: i18n['ariaNextSlide'],\n          onClick: carousel.nav.next,\n          ...attrs,\n          class: [\n            'carousel__next',\n            { 'carousel__next--disabled': nextDisabled.value },\n            attrs.class,\n          ],\n        },\n        slotNext?.() || h(Icon, { name: getNextIcon() })\n      )\n\n      return [prevButton, nextButton]\n    }\n  },\n})\n","import { computed, defineComponent, h, inject, PropType, VNode } from 'vue'\n\nimport { injectCarousel } from '@/shared'\nimport { getSnapAlignOffset, i18nFormatter, mapNumberToRange } from '@/utils'\n\nimport { PaginationProps } from './Pagination.types'\n\nexport const Pagination = defineComponent<PaginationProps>({\n  name: 'CarouselPagination',\n  props: {\n    disableOnClick: {\n      type: Boolean,\n    },\n    paginateByItemsToShow: {\n      type: Boolean,\n    },\n    carousel: {\n      type: Object as PropType<PaginationProps['carousel']>,\n    }\n  },\n  setup(props) {\n    let carousel = inject(injectCarousel, null)!\n\n    const itemsToShow = computed(() => carousel.config.itemsToShow as number)\n    const offset = computed(() =>\n      getSnapAlignOffset({\n        align: carousel.config.snapAlign,\n        itemsToShow: itemsToShow.value,\n      })\n    )\n    const isPaginated = computed(\n      () => props.paginateByItemsToShow && itemsToShow.value > 1\n    )\n    const currentPage = computed(() =>\n      Math.ceil((carousel.activeSlide - offset.value) / itemsToShow.value)\n    )\n    const pageCount = computed(() => Math.ceil(carousel.slidesCount / itemsToShow.value))\n\n    const isActive = (slide: number): boolean =>\n      mapNumberToRange(\n        isPaginated.value\n          ? {\n              val: currentPage.value,\n              max: pageCount.value - 1,\n              min: 0,\n            }\n          : {\n              val: carousel.activeSlide,\n              max: carousel.maxSlide,\n              min: carousel.minSlide,\n            }\n      ) === slide\n\n    return () => {\n      if (props.carousel) {\n        carousel = props.carousel;\n      }\n      if (!carousel) {\n        console.warn('[vue3-carousel]: A carousel component must be provided for the pagination component to display')\n        return '';\n      }\n      const children: Array<VNode> = []\n\n      for (\n        let slide = isPaginated.value ? 0 : carousel.minSlide;\n        slide <= (isPaginated.value ? pageCount.value - 1 : carousel.maxSlide);\n        slide++\n      ) {\n        const buttonLabel = i18nFormatter(\n          carousel.config.i18n[\n            isPaginated.value ? 'ariaNavigateToPage' : 'ariaNavigateToSlide'\n          ],\n          {\n            slideNumber: slide + 1,\n          }\n        )\n        const active = isActive(slide)\n        const button = h('button', {\n          type: 'button',\n          class: {\n            'carousel__pagination-button': true,\n            'carousel__pagination-button--active': active,\n          },\n          'aria-label': buttonLabel,\n          'aria-pressed': active,\n          'aria-controls': carousel.slides[slide]?.exposed?.id,\n          title: buttonLabel,\n          disabled: props.disableOnClick,\n          onClick: () =>\n            carousel.nav.slideTo(\n              isPaginated.value\n                ? Math.floor(slide * +carousel.config.itemsToShow + offset.value)\n                : slide\n            ),\n        })\n        const item = h('li', { class: 'carousel__pagination-item', key: slide }, button)\n        children.push(item)\n      }\n\n      return h('ol', { class: 'carousel__pagination' }, children)\n    }\n  },\n})\n","import {\n  ComputedRef,\n  computed,\n  defineComponent,\n  DeepReadonly,\n  getCurrentInstance,\n  h,\n  inject,\n  onMounted,\n  onUnmounted,\n  onUpdated,\n  provide,\n  ref,\n  SetupContext,\n  useId,\n} from 'vue'\n\nimport { injectCarousel } from '@/shared'\nimport { disableChildrenTabbing } from '@/utils'\n\nimport { SlideProps } from './Slide.types'\n\nexport const Slide = defineComponent({\n  name: 'CarouselSlide',\n  props: {\n    id: {\n      type: String,\n      default: (props: { isClone?: boolean }) => (props.isClone ? undefined : useId()),\n    },\n    index: {\n      type: Number,\n      default: undefined,\n    },\n    isClone: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props: DeepReadonly<SlideProps>, { attrs, slots, expose }: SetupContext) {\n    const carousel = inject(injectCarousel)\n    provide(injectCarousel, undefined) // Don't provide for nested slides\n\n    if (!carousel) {\n      return () => '' // Don't render, let vue warn about the missing provide\n    }\n\n    const currentIndex = ref(props.index)\n\n    const setIndex = (newIndex: number) => {\n      currentIndex.value = newIndex\n    }\n\n    const instance = getCurrentInstance()!\n\n    const getBoundingRect = () => {\n      const el = instance.vnode.el as HTMLElement\n      return el ? el.getBoundingClientRect() : { width: 0, height: 0 }\n    }\n\n    expose({\n      id: props.id,\n      setIndex,\n      getBoundingRect,\n    })\n\n    const isActive: ComputedRef<boolean> = computed(\n      () => currentIndex.value === carousel.activeSlide\n    )\n    const isPrev: ComputedRef<boolean> = computed(\n      () => currentIndex.value === carousel.activeSlide - 1\n    )\n    const isNext: ComputedRef<boolean> = computed(\n      () => currentIndex.value === carousel.activeSlide + 1\n    )\n    const isVisible: ComputedRef<boolean> = computed(\n      () =>\n        currentIndex.value >= carousel.visibleRange.min &&\n        currentIndex.value <= carousel.visibleRange.max\n    )\n\n    const slideStyle = computed(() => {\n      if (carousel.config.itemsToShow === 'auto') {\n        return\n      }\n      const itemsToShow = carousel.config.itemsToShow\n      const dimension =\n        carousel.config.gap > 0 && itemsToShow > 1\n          ? `calc(${100 / itemsToShow}% - ${\n              (carousel.config.gap * (itemsToShow - 1)) / itemsToShow\n            }px)`\n          : `${100 / itemsToShow}%`\n\n      return carousel.isVertical ? { height: dimension } : { width: dimension }\n    })\n\n    carousel.slideRegistry.registerSlide(instance, props.index)\n    onUnmounted(() => {\n      carousel.slideRegistry.unregisterSlide(instance)\n    })\n\n    if (props.isClone) {\n      // Prevent cloned slides from being focusable\n      onMounted(() => {\n        disableChildrenTabbing(instance.vnode)\n      })\n      onUpdated(() => {\n        disableChildrenTabbing(instance.vnode)\n      })\n    }\n\n    return () => {\n      if (!carousel.config.enabled) {\n        return slots.default?.()\n      }\n\n      return h(\n        'li',\n        {\n          style: [attrs.style, { ...slideStyle.value }],\n          class: {\n            carousel__slide: true,\n            'carousel__slide--clone': props.isClone,\n            'carousel__slide--visible': isVisible.value,\n            'carousel__slide--active': isActive.value,\n            'carousel__slide--prev': isPrev.value,\n            'carousel__slide--next': isNext.value,\n            'carousel__slide--sliding': carousel.isSliding,\n          },\n          onFocusin: () => {\n            // Prevent the viewport being scrolled by the focus\n            if (carousel.viewport) {\n              carousel.viewport.scrollLeft = 0\n            }\n            carousel.nav.slideTo(currentIndex.value)\n          },\n          id: props.isClone ? undefined : props.id,\n          'aria-hidden': props.isClone || undefined,\n          tabindex: props.isClone || !isVisible.value ? -1 : undefined,\n        },\n        slots.default?.({\n          currentIndex: currentIndex.value,\n          isActive: isActive.value,\n          isClone: props.isClone,\n          isPrev: isPrev.value,\n          isNext: isNext.value,\n          isSliding: carousel.isSliding,\n          isVisible: isVisible.value,\n        })\n      )\n    }\n  },\n})\n"],"names":["BREAKPOINT_MODE_OPTIONS","DIR_MAP","DIR_OPTIONS","I18N_DEFAULT_CONFIG","ariaGallery","ariaNavigateToPage","ariaNavigateToSlide","ariaNextSlide","ariaPreviousSlide","iconArrowDown","iconArrowLeft","iconArrowRight","iconArrowUp","itemXofY","NORMALIZED_DIR_OPTIONS","Object","values","SLIDE_EFFECTS","SNAP_ALIGN_OPTIONS","DEFAULT_DRAG_THRESHOLD","DEFAULT_CONFIG","autoplay","breakpointMode","breakpoints","undefined","dir","enabled","gap","height","i18n","ignoreAnimations","itemsToScroll","itemsToShow","modelValue","mouseDrag","mouseWheel","pauseAutoplayOnHover","preventExcessiveDragging","slideEffect","snapAlign","touchDrag","transition","transitionEasing","wrapAround","injectCarousel","Symbol","createSlideRegistry","emit","slides","shallowReactive","updateSlideIndexes","startIndex","slice","forEach","slide","offset","_a","exposed","setIndex","index","cleanup","splice","length","getSlides","registerSlide","props","isClone","slideIndex","unregisterSlide","indexOf","createCloneSlides","position","toShow","clones","isBefore","start","end","i","id","key","vnode","clone","cloneVNode","el","push","disableChildrenTabbing","node","Element","elements","querySelectorAll","HTMLElement","hasAttribute","getAttribute","setAttribute","getNumberInRange","val","max","min","Math","isNaN","transformCache","WeakMap","invalidateTransformCache","delete","getScaleMultipliers","transformElements","size","widthMultiplier","heightMultiplier","transformArr","cached","get","transform","window","getComputedStyle","result","set","split","map","v","parseFloat","some","getTransformValues","scaleX","scaleY","getSnapAlignOffset","slideSize","viewportSize","align","getSnapAlignOffsetByItemsToShow","getSnapAlignOffsetBySlideAndViewport","i18nFormatter","string","entries","reduce","acc","value","replace","String","mapNumberToRange","mod","throttle","fn","ms","isThrottled","timeoutId","frameId","throttled","args","setTimeout","requestAnimationFrame","cancel","clearTimeout","cancelAnimationFrame","toCssValue","unit","toString","ARIA","defineComponent","name","setup","carousel","inject","h","class","config","currentSlide","slidesCount","carouselProps","default","type","Number","validator","isValid","includes","console","warn","join","clamp","Boolean","Array","mouseScrollThreshold","Carousel","emits","slots","expose","slideRegistry","computed","root","ref","viewport","fallbackConfig","assign","obj","keys","filter","k","currentSlideIndex","activeSlideIndex","watch","prevSlideIndex","middleSlideIndex","ceil","maxSlideIndex","minSlideIndex","autoplayTimer","transitionTimer","resizeObserver","effectiveSlideSize","normalizedDir","isReversed","isVertical","isAuto","dimension","updateBreakpointsConfig","mounted","widthSource","getBoundingClientRect","width","innerWidth","breakpointsArray","sort","a","b","newConfig","breakpoint","Infinity","handleResize","updateSlidesData","updateSlideSize","Set","slidesRect","viewportRect","scaleMultipliers","rect","updateViewportRectSize","getBoundingRect","updateSlidesRectSize","numbers","validNumbers","num","isFinite","calculateAverage","totalGap","isArray","animationInterval","watchEffect","setAnimationInterval","event","target","contains","animationName","add","stepAnimation","finishAnimation","document","addEventListener","passive","removeEventListener","onMounted","initAutoplay","ResizeObserver","observe","onBeforeUnmount","clearInterval","disconnect","handleBlur","isHover","handleMouseEnter","handleMouseLeave","useHover","handleArrowKeys","ctrlKey","endsWith","next","prev","handleFocus","setInterval","resetAutoplay","stopAutoplay","isSliding","dragged","isDragging","handleDragStart","options","isTouch","startPosition","x","y","reactive","sliding","handleDrag","touches","currentX","clientX","currentY","clientY","onDrag","call","deltaX","deltaY","handleDragEnd","draggedDistance","abs","e","preventDefault","stopPropagation","once","capture","onDragEnd","moveEvent","endEvent","targetTagName","tagName","button","onDragStart","useDrag","threshold","_b","_d","_c","draggedSlides","params","dragValue","dragRatio","absRatio","slidesDragged","sign","round","getDraggedSlidesCount","slideTo","handleScroll","vertical","primaryDelta","isScrollingForward","onWheel","useWheel","skipTransition","targetIndex","slidingToIndex","modelWatcher","pause","resume","deep","clonedSlidesCount","before","after","slidesToClone","clonedSlidesOffset","snapAlignOffset","scrolledOffset","output","scrolledSlides","visibleRange","base","floor","minIndex","accumulatedSize","iterations","maxIterations","normalizedIndex","maxIndex","trackTransform","translateAxis","dragOffset","totalOffset","maxSlidingValue","carouselStyle","nav","provided","activeSlide","maxSlide","minSlide","provide","data","middleSlide","restartCarousel","toRefs","slotSlides","outputSlides","addonsElements","addons","trackEl","onMousedownCapture","onTouchstartPassiveCapture","style","viewPortEl","tabindex","onBlur","onFocus","onMouseenter","onMouseleave","ARIAComponent","IconName","iconI18n","charAt","toUpperCase","icons","arrowDown","arrowLeft","arrowRight","arrowUp","validateIconName","Icon","required","title","iconName","path","pathEl","d","iconTitle","titleEl","viewBox","role","Navigation","inheritAttrs","attrs","slotNext","slotPrev","prevDisabled","nextDisabled","disabled","onClick","btt","ltr","rtl","ttb","Pagination","disableOnClick","paginateByItemsToShow","isPaginated","currentPage","pageCount","isActive","children","buttonLabel","slideNumber","active","item","Slide","useId","currentIndex","instance","getCurrentInstance","newIndex","isPrev","isNext","isVisible","slideStyle","onUnmounted","onUpdated","carousel__slide","onFocusin","scrollLeft"],"mappings":"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"}